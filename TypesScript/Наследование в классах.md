В JS/TS наследование работает так же, как и в других ООП языках. Вот пример:
```TS
class Animal {
	constructor(public name: string) {}
	
	speak() {
		console.log(`${this.name} makes a noise`);
	}
}

class Dog extends Animal {
	constructor(name: string) {
		super(name); // Вызов конструктора родительского класса
	}

	speak() {
		console.log(`${this.name} barks`)
	}
}

const dog = new Dog('Buddy')
dog.speak(); // Вызов родительского метода из дочернего класса
```

Под капотом:
 - `extends` - Это ключевое слово указывает, что класс наследует свойства и методы другого класса.
 - `super()` - Используется для инициализации свойства родительского класса. Это важно, если родительский класс имеет свой конструктор.
 - Если дочерний класс переопределяет методы родителя, такие как `speak()`, то при вызове этого метода будет использована версия, определенная в дочернем классе.

---
**Прототипное наследование** - это механизм в JS, при котором объекты могут наследовать свойства и методы от других объектов Вместо классов, как в традиционных ООП языках, JS использует объекты и их связи через прототипы.

**Прототипом** является объект, от которого объект может унаследовать свойства и методы.

`__proto__` - это ссылка на объект, который является прототипом текущего объекта. Каждое свойство объекта в JS имеет цепочку прототипов, по которой будет искать это свойство (если оно не найдено в самом объекте).
`prototype` - это свойство функции-конструктора, которое используется для добавления методов и свойств, доступных всем экземплярам объектов, созданным с помощью этой функции конструктора.
```TS

// Тот же самый пример что и выше, только класс работает через прототип
function Animal(name) {
	this.name = name;
}

Animal.prototype.speak = function() {
	console.log(`${this.name} makes`)
}

const dog = new Animal('Boddy');
dog.speak();
```


**Под капотом это работает так:**
Когда создаётся объект с помощью конструктора (например, `new Animal()`), JS создает объект и связывает его с прототипом через `__proto__`. Если вы вызываете метод или обращаетесь к свойство объекта, JS сначала проверяет сам объект. Если оно не найдено, поиск продолжается по цепочке прототипов (то есть, через `__proto__`). `prototype` указывает на объект который является прототипом для всех экземпляров, созданных через функцию-конструктор. Если метод добавляется в `prototype`, то он будет доступен всем экземплярам этого конструктора.

Пример цепочки прототипов: 
```TS
const obj = {a: 1}
console.log(obj.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```
Таким образом, объекты в JS имеют цепочку прототипов, которая используется для поиска свойств и методов, и это работает через свойства `__proto__` и `prototype`

