## Что такое Promise?

`Promise` — это объект, который представляет результат асинхронной операции. Он может находиться в одном из трёх состояний:

- **pending** (ожидание) — операция ещё не завершена;
- **fulfilled** (выполнена успешно) — операция завершилась успешно и есть результат;
- **rejected** (отклонена) — операция завершилась с ошибкой.

Promise позволяет работать с асинхронным кодом более удобно, избегая "ад коллбэков".

---

## Основные методы Promise

### Создание Promise

```js
const promise = new Promise((resolve, reject) => {
  // Асинхронная операция
  if (успех) {
    resolve(value);   // успешный результат
  } else {
    reject(error);    // ошибка
  }
});


### Методы экземпляра Promise

- **then(onFulfilled, onRejected?)** — регистрирует обработчик успешного результата и/или ошибки. Возвращает новый Promise.
    
- **catch(onRejected)** — то же что `then(null, onRejected)`. Обрабатывает ошибку.
    
- **finally(onFinally)** — вызывается в любом случае, после выполнения или ошибки. Не меняет результат.
    

Пример:

```js
promise
  .then(result => console.log('Success:', result))
  .catch(error => console.error('Error:', error))
  .finally(() => console.log('Done'));
```

---

## Методы класса Promise (статические)

- **Promise.resolve(value)** — возвращает Promise, который сразу выполнится с `value`.
    
- **Promise.reject(error)** — возвращает Promise, который сразу отклонится с `error`.
    
- **Promise.all(iterable)** — принимает массив промисов и возвращает новый промис, который выполнится, когда все промисы из массива выполнятся успешно, или отклонится, если хотя бы один промис отклонится.
    
- **Promise.race(iterable)** — возвращает промис, который выполнится или отклонится, как только первый промис из массива выполнится или отклонится.
    
- **Promise.allSettled(iterable)** — возвращает промис, который выполнится, когда все промисы завершатся (успешно или с ошибкой), с массивом результатов.
    
- **Promise.any(iterable)** — возвращает промис, который выполнится с первым успешно выполненным промисом из массива или отклонится, если все промисы отклонятся.
    

---

## Async / Await

`async` и `await` — синтаксический сахар над промисами, позволяющий писать асинхронный код как синхронный.

- Функция, объявленная с `async`, всегда возвращает Promise.
    
- Оператор `await` приостанавливает выполнение функции, пока промис не выполнится.
    

Пример:

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Ошибка:', error);
  }
}
```

---

## try / catch / finally

Конструкция для обработки исключений:

```js
try {
  // Код, который может выбросить ошибку
} catch (error) {
  // Обработка ошибки
} finally {
  // Код, который выполнится в любом случае
}
```

В асинхронных функциях try/catch ловит ошибки, которые произошли при `await`.

---

## Как отправить функцию в микрозадачи?

Микрозадачи — это задачи, которые выполняются сразу после текущего скрипта, но до отрисовки и макрозадач (таймеров, событий).

Чтобы принудительно поместить функцию в очередь микрозадач:

```js
Promise.resolve().then(() => {
  // Этот код выполнится в микрозадаче
});
```

Или в async функции:

```js
async function microtask() {
  await null; // await ставит оставшуюся часть функции в микрозадачи
  console.log('В микрозадаче');
}
microtask();
```

---

# Итог

|Концепция|Описание|
|---|---|
|Promise|Асинхронный объект с состояниями|
|then / catch / finally|Методы для обработки результата и ошибок|
|Promise.all / race|Статические методы для работы с массивом промисов|
|async / await|Синтаксис для удобной работы с промисами|
|try / catch / finally|Обработка исключений|
|Promise.resolve().then|Поместить код в очередь микрозадач|
