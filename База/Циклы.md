- Цикл "`for (let i = 0; i < arr.length; i++)`" - выполняется синхронно и просто перебирает значения.
- Цикл "`for await (const arrPromise of arrayPromise)`" - Работает чисто с ассинхронными операциями, и ожидает завершения каждой операции. Под капотом вызывая `[Symbol.asyncIterator]()`, который вызывает асинхронный итератор с методом `next()` возвращающий `Promise<{value, done}>`.
- Цикл "`for(const arr of array)`" - Работает с массивами, позволяет работать так-же с асинхронными массивами, благодаря тому что цикл будет ждать, пока выполнится await. 
  Так как под капотом вызывает метод `[Symbol.iterator]()`, который возвращает итератор с методом `next()` 
- Цикл "`for(const obj in object)`" - Используется для перебора ключей объектов. Без `hasOwnProperty()` захватывает унаследованные свойства. Порядок перебора не гарантирован. В современном js чаще используются `Object.keys(), Object.values(), Object.entries()`

---
# Отличие `Object.keys()`, `Object.values()`, `Object.entries()` от `for...in`

| Что перебирает          | `for...in`                      | `Object.keys()/values()/entries()`         |
|-------------------------|--------------------------------|--------------------------------------------|
| Свойства объекта        | Все перечислимые, включая унаследованные | Только собственные свойства (без унаследованных) |
| Нужно ли фильтровать    | Да, через `hasOwnProperty`      | Нет, фильтрация встроена                    |
| Порядок перебора        | Не гарантирован                 | Гарантирован                                |
| Возвращаемое значение   | Ключи (строки)                 | Массив ключей, значений или пар `[ключ, значение]` |
| Удобство                | Менее удобно                   | Удобно, можно сразу использовать методы массива |

---

# Преимущества

- **`for...in`**  
  - Может видеть унаследованные свойства  
  - Нужно фильтровать, чтобы не взять лишнее  
  - Порядок может быть случайным

- **`Object.keys()/values()/entries()`**  
  - Только свои свойства  
  - Возвращают массивы — удобно работать  
  - Порядок всегда одинаковый  

---

# Пример

```js
const proto = { inherited: 'yes' };
const obj = Object.create(proto);
obj.a = 1;
obj.b = 2;

for (const key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key); // 'a', 'b'
  }
}

console.log(Object.keys(obj));    // ['a', 'b']
console.log(Object.values(obj));  // [1, 2]
console.log(Object.entries(obj)); // [['a', 1], ['b', 2]]